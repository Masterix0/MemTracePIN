# Trace Analyzer

The Trace Analysis Tool is a Java-based simulator designed to analyze memory access trace files generated by the custom Intel® PIN tool [MemTracePIN](https://github.com/Masterix0/MemTracePIN).
It simulates page placement strategies in heterogeneous memory systems by dividing program execution into intervals and applying different page-ranking mechanisms.
The tool calculates DRAM hit ratios and provides detailed metrics for each interval, facilitating performance analysis and optimization of memory systems.

## Table of Contents

- [Features](#features)
- [Requirements](#requirements)
- [Installation](#installation)
- [Usage](#usage)
  - [Command-Line Arguments](#command-line-arguments)
  - [Example](#example)
- [Running Multiple Analyses](#running-multiple-analyses)
- [Output](#output)
- [Variance Calculation](#variance-calculation)
- [Visualization](#visualization)
- [Cleaning Up](#cleaning-up)
- [Troubleshooting](#troubleshooting)
- [Acknowledgments](#acknowledgments)

## Features

- **Simulates Page-Ranking Mechanisms**: Implements four page-ranking strategies:
  - **Total Number of Accesses**: Ranks pages based on total access count.
  - **First Access Time**: Ranks pages based on the time of first access.
  - **Page Table Scan (PTS) Scoring**: Ranks pages using an approximation of PTS scoring over sub-intervals.
  - **MicroChronos**: Approximates the ranking based on an approximation of the MicroChronos algorithm, which approximates first access time using variable sub-intervals.

- **Interval-Based Analysis**: Divides execution into user-defined intervals for granular analysis.

- **Customizable Parameters**: Allows adjustment of DRAM capacity percentage, interval durations, and sub-interval durations.

- **Multi-threaded Processing**: Utilizes multi-threading to efficiently process large trace files.

- **Detailed Output**: Generates CSV files with metrics for each interval, including DRAM hit ratios and access counts.

- **Variance Calculation**: Computes overall DRAM hit ratios and variance across intervals.

- **Visualization Support**: Compatible with a Python script to generate graphs from the output CSV files.

## Requirements

- **Operating System**: Linux
- **Java Development Kit (JDK)**: Version 8 or higher
- **Make**: For compilation (optional but recommended)
- **Python 3**: For visualization scripts (optional)

## Installation

1. **Clone the Repository**:

   ```bash
   git clone https://github.com/Masterix0/MemTracePIN
   ```

2. **Navigate to the Directory**:

   ```bash
   cd MemTracePIN/TraceAnalyzer
   ```

3. **Compile the Project**:

   Use the provided `Makefile` to compile the Java source code:

   ```bash
   make
   ```

   This will create a `bin` directory containing the compiled class files.

   **Note**: Ensure that `make` is installed on your system.

## Usage

### Command-Line Arguments

The tool is executed via the command line with the following syntax:

```bash
java -cp bin TraceAnalyzer <workload_name> <real_time_interval_ms> <real_time_run_ms> <tracing_run_ms> <trace_directory> <dram_percentage> <sub_interval_duration_ms>
```

**Arguments**:

- **`workload_name`**:  
  A unique identifier for the workload being analyzed. This name is used for naming output files.  
  **Important**: Avoid spaces or hyphens (`-`) in the name; use underscores (`_`) instead.

- **`real_time_interval_ms`**:  
  The size of each interval window in milliseconds, representing real execution time.

- **`real_time_run_ms`**:  
  The total real execution time of the workload in milliseconds.

- **`tracing_run_ms`**:  
  The total execution time during tracing in milliseconds. Tracing usually introduces overhead, making this value significantly larger than `real_time_run_ms`.

- **`trace_directory`**:  
  Path to the directory containing the sorted trace files generated by the tracer.

- **`dram_percentage`**:  
  Fraction of accessed pages assumed to fit in DRAM during each interval (e.g., `0.3` for 30%).

- **`sub_interval_duration_ms`**:  
  Duration of each sub-interval in milliseconds for PTS scoring and as the base duration for MicroChronos sub-intervals.

### Example

```bash
java -cp bin TraceAnalyzer my_workload 3 12 25000 ../MyPinTool/sorted/ 0.3 1
```

This command runs the Trace Analyzer with:

- **Workload Name**: `my_workload`
- **Interval Window**: 3 milliseconds
- **Real Runtime**: 12 milliseconds
- **Tracing Runtime**: 25,000 milliseconds (25 seconds)
- **Trace Directory**: `../MyPinTool/sorted/`
- **DRAM Percentage**: 30%
- **Sub-Interval Duration**: 1 millisecond

**Notes**:

- Ensure that the trace files in the specified directory are sorted by timestamp.
- For large trace files, you may need to increase the Java heap size using the `-Xmx` option:

  ```bash
  java -Xmx16g -cp bin TraceAnalyzer [arguments]
  ```

  Replace `16g` with the appropriate amount of memory (e.g., `32g` for 32 GB).

## Running Multiple Analyses

You can automate multiple analyses using the provided Bash script `run_tracer_commands.sh` and a command list file. This is particularly useful when you want to run the trace analyzer with different parameters and log all terminal output to a file.

### Steps:

1. **Create a Command List File**:

   - Name the file `tracer_commands_list.txt`.
   - Each line should contain a complete command to execute, for example:

     ```bash
     time java -Xmx58g -cp bin TraceAnalyzer mega_simulation 100 2923 1269960000 ~/a/sample/path/to/workload/ 0.2 20
     time java -Xmx58g -cp bin TraceAnalyzer wham_a_lam_LLM 100 3200 1300000000 ~/a/sample/path/to/workload/ 0.3 15
     ```

2. **Run the Script**:

   ```bash
   ./run_tracer_commands.sh
   ```

   The script will execute each command and log the output to `tracer_output.log`.

**Note**: Ensure the script has execute permissions:

```bash
chmod +x run_tracer_commands.sh
```

## Output

The tool generates a CSV file in the `output` directory with a filename format:

```
<workload_name>-<interval_window_ms>-<sub_interval_duration_ms>-<dram_percentage>.csv
```

**Example**:

```
my_workload-3-1.00-0.30.csv
```

**CSV Columns**:

- `interval_start_timestamp`
- `interval_end_timestamp`
- `number_of_pages_accessed`
- `total_access_count`
- `actual_accesses_dram_hit_ratio`
- `estimated_dram_hit_ratio`
- `pts_dram_hit_ratio`
- `microchronos_dram_hit_ratio`

**Overall DRAM Hit Ratios and Variance**:

At the end of the analysis, the tool prints the overall DRAM hit ratios and variance for each ranking mechanism to the console.

## Variance Calculation

The tool treats each interval as part of the entire population of the program execution.
Variance is calculated across all intervals for each page-ranking mechanism to assess the stability of DRAM hit ratios over time.

## Visualization

A Python script `visualize_outputs.py` is provided in the `visualizer` directory to generate graphs from the output CSV files.

### Requirements

- **Python 3.x**
- **Python Packages**:
  - `pandas`
  - `matplotlib`
  - `numpy`

Install the required packages using `pip`:

```bash
pip3 install pandas matplotlib numpy
```

### Usage

1. **Navigate to the Visualizer Directory**:

   ```bash
   cd visualizer
   ```

2. **Run the Visualization Script**:

   ```bash
   python3 visualize_outputs.py
   ```

   This script reads all CSV files in the `output` directory and generates plots in the `plots` subdirectory.

### Generated Plots

- **DRAM Hit Ratios Over Time**: Compares DRAM hit ratios of different page-ranking mechanisms.
- **DRAM Hit Ratio Difference Over Time**: Presents the DRAM hit ratio difference between First Access Time ranking and Total Number of Accesses ranking.
- **Number of Pages Accessed Over Time**: Shows how the number of accessed pages changes over time.
- **Total Access Count Over Time**: Displays the total number of memory accesses per interval.
- **Overall DRAM Hit Ratios**: Bar charts summarizing overall DRAM hit ratios per workload.

### Customization

You can adjust the number of columns in the plots by modifying the `cols` variable in the `visualize_outputs.py` script.

## Cleaning Up

To remove compiled classes and output files, run:

```bash
make clean
```

This command deletes the `bin` directory and the `output` directory.

**Note**: It does not remove the `visualizer` directory or any scripts.

## Troubleshooting

- **OutOfMemoryError**:  
  If you encounter a Java `OutOfMemoryError`, increase the heap size using the `-Xmx` flag.

- **Incorrect Output**:  
  Ensure that your trace files are sorted by timestamp. Unsorted trace files can lead to incorrect analysis.

- **Script Permissions**:  
  If you cannot execute `run_tracer_commands.sh`, make sure it has the correct permissions:

  ```bash
  chmod +x run_tracer_commands.sh
  ```

- **Missing Directories**:  
  If the `output` directory is missing, the tool should create it automatically. If not, create it manually:

  ```bash
  mkdir output
  ```

- **Python Module Errors**:  
  If the visualization script fails due to missing modules, install them using `pip` as shown in the [Visualization](#visualization) section.

## Acknowledgments

MemTracePIN was developed as part of a master's thesis project at [Instituto Superior Técnico, Universidade de Lisboa](https://tecnico.ulisboa.pt/en/). It aims to assist future students and researchers in the field of memory systems and performance analysis.

- **Author**: André Gonçalves
- **Contact**: [andreafonsogoncalves2001@gmail.com](mailto:andreafonsogoncalves2001@gmail.com)

We acknowledge the use of Intel® PIN for dynamic binary instrumentation.